import { defu } from "defu";
import { AsyncLocalStorage } from "node:async_hooks";
import nodeCrypto from "node:crypto";

//#region ../../node_modules/.pnpm/cookie-es@1.2.2/node_modules/cookie-es/dist/index.mjs
function parse(str, options) {
	if (typeof str !== "string") throw new TypeError("argument str must be a string");
	const obj = {};
	const opt = options || {};
	const dec = opt.decode || decode$1;
	let index = 0;
	while (index < str.length) {
		const eqIdx = str.indexOf("=", index);
		if (eqIdx === -1) break;
		let endIdx = str.indexOf(";", index);
		if (endIdx === -1) endIdx = str.length;
		else if (endIdx < eqIdx) {
			index = str.lastIndexOf(";", eqIdx - 1) + 1;
			continue;
		}
		const key = str.slice(index, eqIdx).trim();
		if (opt?.filter && !opt?.filter(key)) {
			index = endIdx + 1;
			continue;
		}
		if (void 0 === obj[key]) {
			let val = str.slice(eqIdx + 1, endIdx).trim();
			if (val.codePointAt(0) === 34) val = val.slice(1, -1);
			obj[key] = tryDecode(val, dec);
		}
		index = endIdx + 1;
	}
	return obj;
}
function decode$1(str) {
	return str.includes("%") ? decodeURIComponent(str) : str;
}
function tryDecode(str, decode2) {
	try {
		return decode2(str);
	} catch {
		return str;
	}
}
const fieldContentRegExp = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
function serialize(name, value, options) {
	const opt = options || {};
	const enc = opt.encode || encodeURIComponent;
	if (typeof enc !== "function") throw new TypeError("option encode is invalid");
	if (!fieldContentRegExp.test(name)) throw new TypeError("argument name is invalid");
	const encodedValue = enc(value);
	if (encodedValue && !fieldContentRegExp.test(encodedValue)) throw new TypeError("argument val is invalid");
	let str = name + "=" + encodedValue;
	if (void 0 !== opt.maxAge && opt.maxAge !== null) {
		const maxAge = opt.maxAge - 0;
		if (Number.isNaN(maxAge) || !Number.isFinite(maxAge)) throw new TypeError("option maxAge is invalid");
		str += "; Max-Age=" + Math.floor(maxAge);
	}
	if (opt.domain) {
		if (!fieldContentRegExp.test(opt.domain)) throw new TypeError("option domain is invalid");
		str += "; Domain=" + opt.domain;
	}
	if (opt.path) {
		if (!fieldContentRegExp.test(opt.path)) throw new TypeError("option path is invalid");
		str += "; Path=" + opt.path;
	}
	if (opt.expires) {
		if (!isDate(opt.expires) || Number.isNaN(opt.expires.valueOf())) throw new TypeError("option expires is invalid");
		str += "; Expires=" + opt.expires.toUTCString();
	}
	if (opt.httpOnly) str += "; HttpOnly";
	if (opt.secure) str += "; Secure";
	if (opt.priority) switch (typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority) {
		case "low":
			str += "; Priority=Low";
			break;
		case "medium":
			str += "; Priority=Medium";
			break;
		case "high":
			str += "; Priority=High";
			break;
		default: throw new TypeError("option priority is invalid");
	}
	if (opt.sameSite) switch (typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite) {
		case true:
			str += "; SameSite=Strict";
			break;
		case "lax":
			str += "; SameSite=Lax";
			break;
		case "strict":
			str += "; SameSite=Strict";
			break;
		case "none":
			str += "; SameSite=None";
			break;
		default: throw new TypeError("option sameSite is invalid");
	}
	if (opt.partitioned) str += "; Partitioned";
	return str;
}
function isDate(val) {
	return Object.prototype.toString.call(val) === "[object Date]" || val instanceof Date;
}

//#endregion
//#region ../../node_modules/.pnpm/ufo@1.6.1/node_modules/ufo/dist/index.mjs
const r = String.fromCharCode;
const PLUS_RE = /\+/g;
function decode(text = "") {
	try {
		return decodeURIComponent("" + text);
	} catch {
		return "" + text;
	}
}
function decodeQueryKey(text) {
	return decode(text.replace(PLUS_RE, " "));
}
function decodeQueryValue(text) {
	return decode(text.replace(PLUS_RE, " "));
}
function parseQuery(parametersString = "") {
	const object = /* @__PURE__ */ Object.create(null);
	if (parametersString[0] === "?") parametersString = parametersString.slice(1);
	for (const parameter of parametersString.split("&")) {
		const s = parameter.match(/([^=]+)=?(.*)/) || [];
		if (s.length < 2) continue;
		const key = decodeQueryKey(s[1]);
		if (key === "__proto__" || key === "constructor") continue;
		const value = decodeQueryValue(s[2] || "");
		if (object[key] === void 0) object[key] = value;
		else if (Array.isArray(object[key])) object[key].push(value);
		else object[key] = [object[key], value];
	}
	return object;
}
const PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/;
const PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/;
const PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
function hasProtocol(inputString, opts = {}) {
	if (typeof opts === "boolean") opts = { acceptRelative: opts };
	if (opts.strict) return PROTOCOL_STRICT_REGEX.test(inputString);
	return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
}
function getQuery$2(input) {
	return parseQuery(parseURL(input).search);
}
const protocolRelative = Symbol.for("ufo:protocolRelative");
function parseURL(input = "", defaultProto) {
	const _specialProtoMatch = input.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);
	if (_specialProtoMatch) {
		const [, _proto, _pathname = ""] = _specialProtoMatch;
		return {
			protocol: _proto.toLowerCase(),
			pathname: _pathname,
			href: _proto + _pathname,
			auth: "",
			host: "",
			search: "",
			hash: ""
		};
	}
	if (!hasProtocol(input, { acceptRelative: true })) return defaultProto ? parseURL(defaultProto + input) : parsePath(input);
	const [, protocol = "", auth, hostAndPath = ""] = input.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
	let [, host = "", path = ""] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];
	if (protocol === "file:") path = path.replace(/\/(?=[A-Za-z]:)/, "");
	const { pathname, search, hash } = parsePath(path);
	return {
		protocol: protocol.toLowerCase(),
		auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : "",
		host,
		pathname,
		search,
		hash,
		[protocolRelative]: !protocol
	};
}
function parsePath(input = "") {
	const [pathname = "", search = "", hash = ""] = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
	return {
		pathname,
		search,
		hash
	};
}

//#endregion
//#region ../../node_modules/.pnpm/ohash@1.1.6/node_modules/ohash/dist/shared/ohash.BvSMZzli.mjs
const defaults$1 = Object.freeze({
	ignoreUnknown: false,
	respectType: false,
	respectFunctionNames: false,
	respectFunctionProperties: false,
	unorderedObjects: true,
	unorderedArrays: false,
	unorderedSets: false,
	excludeKeys: void 0,
	excludeValues: void 0,
	replacer: void 0
});
function objectHash(object, options) {
	if (options) options = {
		...defaults$1,
		...options
	};
	else options = defaults$1;
	const hasher = createHasher(options);
	hasher.dispatch(object);
	return hasher.toString();
}
const defaultPrototypesKeys = Object.freeze([
	"prototype",
	"__proto__",
	"constructor"
]);
function createHasher(options) {
	let buff = "";
	let context = /* @__PURE__ */ new Map();
	const write = (str) => {
		buff += str;
	};
	return {
		toString() {
			return buff;
		},
		getContext() {
			return context;
		},
		dispatch(value) {
			if (options.replacer) value = options.replacer(value);
			return this[value === null ? "null" : typeof value](value);
		},
		object(object) {
			if (object && typeof object.toJSON === "function") return this.object(object.toJSON());
			const objString = Object.prototype.toString.call(object);
			let objType = "";
			const objectLength = objString.length;
			if (objectLength < 10) objType = "unknown:[" + objString + "]";
			else objType = objString.slice(8, objectLength - 1);
			objType = objType.toLowerCase();
			let objectNumber = null;
			if ((objectNumber = context.get(object)) === void 0) context.set(object, context.size);
			else return this.dispatch("[CIRCULAR:" + objectNumber + "]");
			if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object)) {
				write("buffer:");
				return write(object.toString("utf8"));
			}
			if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
				if (this[objType]) this[objType](object);
				else if (!options.ignoreUnknown) this.unkown(object, objType);
			} else {
				let keys = Object.keys(object);
				if (options.unorderedObjects) keys = keys.sort();
				let extraKeys = [];
				if (options.respectType !== false && !isNativeFunction(object)) extraKeys = defaultPrototypesKeys;
				if (options.excludeKeys) {
					keys = keys.filter((key) => {
						return !options.excludeKeys(key);
					});
					extraKeys = extraKeys.filter((key) => {
						return !options.excludeKeys(key);
					});
				}
				write("object:" + (keys.length + extraKeys.length) + ":");
				const dispatchForKey = (key) => {
					this.dispatch(key);
					write(":");
					if (!options.excludeValues) this.dispatch(object[key]);
					write(",");
				};
				for (const key of keys) dispatchForKey(key);
				for (const key of extraKeys) dispatchForKey(key);
			}
		},
		array(arr, unordered) {
			unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;
			write("array:" + arr.length + ":");
			if (!unordered || arr.length <= 1) {
				for (const entry of arr) this.dispatch(entry);
				return;
			}
			const contextAdditions = /* @__PURE__ */ new Map();
			const entries = arr.map((entry) => {
				const hasher = createHasher(options);
				hasher.dispatch(entry);
				for (const [key, value] of hasher.getContext()) contextAdditions.set(key, value);
				return hasher.toString();
			});
			context = contextAdditions;
			entries.sort();
			return this.array(entries, false);
		},
		date(date) {
			return write("date:" + date.toJSON());
		},
		symbol(sym) {
			return write("symbol:" + sym.toString());
		},
		unkown(value, type) {
			write(type);
			if (!value) return;
			write(":");
			if (value && typeof value.entries === "function") return this.array(Array.from(value.entries()), true);
		},
		error(err) {
			return write("error:" + err.toString());
		},
		boolean(bool) {
			return write("bool:" + bool);
		},
		string(string) {
			write("string:" + string.length + ":");
			write(string);
		},
		function(fn) {
			write("fn:");
			if (isNativeFunction(fn)) this.dispatch("[native]");
			else this.dispatch(fn.toString());
			if (options.respectFunctionNames !== false) this.dispatch("function-name:" + String(fn.name));
			if (options.respectFunctionProperties) this.object(fn);
		},
		number(number) {
			return write("number:" + number);
		},
		xml(xml) {
			return write("xml:" + xml.toString());
		},
		null() {
			return write("Null");
		},
		undefined() {
			return write("Undefined");
		},
		regexp(regex) {
			return write("regex:" + regex.toString());
		},
		uint8array(arr) {
			write("uint8array:");
			return this.dispatch(Array.prototype.slice.call(arr));
		},
		uint8clampedarray(arr) {
			write("uint8clampedarray:");
			return this.dispatch(Array.prototype.slice.call(arr));
		},
		int8array(arr) {
			write("int8array:");
			return this.dispatch(Array.prototype.slice.call(arr));
		},
		uint16array(arr) {
			write("uint16array:");
			return this.dispatch(Array.prototype.slice.call(arr));
		},
		int16array(arr) {
			write("int16array:");
			return this.dispatch(Array.prototype.slice.call(arr));
		},
		uint32array(arr) {
			write("uint32array:");
			return this.dispatch(Array.prototype.slice.call(arr));
		},
		int32array(arr) {
			write("int32array:");
			return this.dispatch(Array.prototype.slice.call(arr));
		},
		float32array(arr) {
			write("float32array:");
			return this.dispatch(Array.prototype.slice.call(arr));
		},
		float64array(arr) {
			write("float64array:");
			return this.dispatch(Array.prototype.slice.call(arr));
		},
		arraybuffer(arr) {
			write("arraybuffer:");
			return this.dispatch(new Uint8Array(arr));
		},
		url(url) {
			return write("url:" + url.toString());
		},
		map(map) {
			write("map:");
			const arr = [...map];
			return this.array(arr, options.unorderedSets !== false);
		},
		set(set) {
			write("set:");
			const arr = [...set];
			return this.array(arr, options.unorderedSets !== false);
		},
		file(file) {
			write("file:");
			return this.dispatch([
				file.name,
				file.size,
				file.type,
				file.lastModfied
			]);
		},
		blob() {
			if (options.ignoreUnknown) return write("[blob]");
			throw new Error("Hashing Blob objects is currently not supported\nUse \"options.replacer\" or \"options.ignoreUnknown\"\n");
		},
		domwindow() {
			return write("domwindow");
		},
		bigint(number) {
			return write("bigint:" + number.toString());
		},
		process() {
			return write("process");
		},
		timer() {
			return write("timer");
		},
		pipe() {
			return write("pipe");
		},
		tcp() {
			return write("tcp");
		},
		udp() {
			return write("udp");
		},
		tty() {
			return write("tty");
		},
		statwatcher() {
			return write("statwatcher");
		},
		securecontext() {
			return write("securecontext");
		},
		connection() {
			return write("connection");
		},
		zlib() {
			return write("zlib");
		},
		context() {
			return write("context");
		},
		nodescript() {
			return write("nodescript");
		},
		httpparser() {
			return write("httpparser");
		},
		dataview() {
			return write("dataview");
		},
		signal() {
			return write("signal");
		},
		fsevent() {
			return write("fsevent");
		},
		tlswrap() {
			return write("tlswrap");
		}
	};
}
const nativeFunc = "[native code] }";
const nativeFuncLength = 15;
function isNativeFunction(f) {
	if (typeof f !== "function") return false;
	return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;
}

//#endregion
//#region ../../node_modules/.pnpm/destr@2.0.5/node_modules/destr/dist/index.mjs
const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
	if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
		warnKeyDropped(key);
		return;
	}
	return value;
}
function warnKeyDropped(key) {
	console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
	if (typeof value !== "string") return value;
	if (value[0] === "\"" && value[value.length - 1] === "\"" && value.indexOf("\\") === -1) return value.slice(1, -1);
	const _value = value.trim();
	if (_value.length <= 9) switch (_value.toLowerCase()) {
		case "true": return true;
		case "false": return false;
		case "undefined": return;
		case "null": return null;
		case "nan": return NaN;
		case "infinity": return Number.POSITIVE_INFINITY;
		case "-infinity": return Number.NEGATIVE_INFINITY;
	}
	if (!JsonSigRx.test(value)) {
		if (options.strict) throw new SyntaxError("[destr] Invalid JSON");
		return value;
	}
	try {
		if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
			if (options.strict) throw new Error("[destr] Possible prototype pollution");
			return JSON.parse(value, jsonParseTransform);
		}
		return JSON.parse(value);
	} catch (error) {
		if (options.strict) throw error;
		return value;
	}
}

//#endregion
//#region ../../node_modules/.pnpm/uncrypto@0.1.3/node_modules/uncrypto/dist/crypto.node.mjs
const subtle = nodeCrypto.webcrypto?.subtle || {};
const randomUUID = () => {
	return nodeCrypto.randomUUID();
};
const getRandomValues = (array) => {
	return nodeCrypto.webcrypto.getRandomValues(array);
};
const _crypto = {
	randomUUID,
	getRandomValues,
	subtle
};

//#endregion
//#region ../../node_modules/.pnpm/iron-webcrypto@1.2.1/node_modules/iron-webcrypto/dist/index.js
var alphabetByEncoding = {};
var alphabetByValue = Array.from({ length: 64 });
for (let i = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i + start <= limit; i++) {
	const char = String.fromCharCode(i + start);
	alphabetByEncoding[char] = i;
	alphabetByValue[i] = char;
}
for (let i = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i + start <= limit; i++) {
	const char = String.fromCharCode(i + start);
	const index = i + 26;
	alphabetByEncoding[char] = index;
	alphabetByValue[index] = char;
}
for (let i = 0; i < 10; i++) {
	alphabetByEncoding[i.toString(10)] = i + 52;
	const char = i.toString(10);
	const index = i + 52;
	alphabetByEncoding[char] = index;
	alphabetByValue[index] = char;
}
alphabetByEncoding["-"] = 62;
alphabetByValue[62] = "-";
alphabetByEncoding["_"] = 63;
alphabetByValue[63] = "_";
var bitsPerLetter = 6;
var bitsPerByte = 8;
var maxLetterValue = 63;
var stringToBuffer = (value) => {
	return new TextEncoder().encode(value);
};
var bufferToString = (value) => {
	return new TextDecoder().decode(value);
};
var base64urlDecode = (_input) => {
	const input = _input + "=".repeat((4 - _input.length % 4) % 4);
	let totalByteLength = input.length / 4 * 3;
	if (input.endsWith("==")) totalByteLength -= 2;
	else if (input.endsWith("=")) totalByteLength--;
	const out = new ArrayBuffer(totalByteLength);
	const dataView = new DataView(out);
	for (let i = 0; i < input.length; i += 4) {
		let bits = 0;
		let bitLength = 0;
		for (let j = i, limit = i + 3; j <= limit; j++) if (input[j] === "=") bits >>= bitsPerLetter;
		else {
			if (!(input[j] in alphabetByEncoding)) throw new TypeError(`Invalid character ${input[j]} in base64 string.`);
			bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;
			bitLength += bitsPerLetter;
		}
		const chunkOffset = i / 4 * 3;
		bits >>= bitLength % bitsPerByte;
		const byteLength = Math.floor(bitLength / bitsPerByte);
		for (let k = 0; k < byteLength; k++) {
			const offset = (byteLength - k - 1) * bitsPerByte;
			dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);
		}
	}
	return new Uint8Array(out);
};
var base64urlEncode = (_input) => {
	const input = typeof _input === "string" ? stringToBuffer(_input) : _input;
	let str = "";
	for (let i = 0; i < input.length; i += 3) {
		let bits = 0;
		let bitLength = 0;
		for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {
			bits |= input[j] << (limit - j - 1) * bitsPerByte;
			bitLength += bitsPerByte;
		}
		const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);
		bits <<= bitClusterCount * bitsPerLetter - bitLength;
		for (let k = 1; k <= bitClusterCount; k++) {
			const offset = (bitClusterCount - k) * bitsPerLetter;
			str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];
		}
	}
	return str;
};
var defaults = {
	encryption: {
		saltBits: 256,
		algorithm: "aes-256-cbc",
		iterations: 1,
		minPasswordlength: 32
	},
	integrity: {
		saltBits: 256,
		algorithm: "sha256",
		iterations: 1,
		minPasswordlength: 32
	},
	ttl: 0,
	timestampSkewSec: 60,
	localtimeOffsetMsec: 0
};
var clone = (options) => ({
	...options,
	encryption: { ...options.encryption },
	integrity: { ...options.integrity }
});
var algorithms = {
	"aes-128-ctr": {
		keyBits: 128,
		ivBits: 128,
		name: "AES-CTR"
	},
	"aes-256-cbc": {
		keyBits: 256,
		ivBits: 128,
		name: "AES-CBC"
	},
	sha256: {
		keyBits: 256,
		name: "SHA-256"
	}
};
var macPrefix = "Fe26.2";
var randomBytes = (_crypto$1, size) => {
	const bytes = new Uint8Array(size);
	_crypto$1.getRandomValues(bytes);
	return bytes;
};
var randomBits = (_crypto$1, bits) => {
	if (bits < 1) throw new Error("Invalid random bits count");
	return randomBytes(_crypto$1, Math.ceil(bits / 8));
};
var pbkdf2 = async (_crypto$1, password, salt, iterations, keyLength, hash) => {
	const passwordBuffer = stringToBuffer(password);
	const importedKey = await _crypto$1.subtle.importKey("raw", passwordBuffer, { name: "PBKDF2" }, false, ["deriveBits"]);
	const params = {
		name: "PBKDF2",
		hash,
		salt: stringToBuffer(salt),
		iterations
	};
	return await _crypto$1.subtle.deriveBits(params, importedKey, keyLength * 8);
};
var generateKey = async (_crypto$1, password, options) => {
	var _a;
	if (!(password == null ? void 0 : password.length)) throw new Error("Empty password");
	if (options == null || typeof options !== "object") throw new Error("Bad options");
	if (!(options.algorithm in algorithms)) throw new Error(`Unknown algorithm: ${options.algorithm}`);
	const algorithm = algorithms[options.algorithm];
	const result = {};
	const hmac = (_a = options.hmac) != null ? _a : false;
	const id = hmac ? {
		name: "HMAC",
		hash: algorithm.name
	} : { name: algorithm.name };
	const usage = hmac ? ["sign", "verify"] : ["encrypt", "decrypt"];
	if (typeof password === "string") {
		if (password.length < options.minPasswordlength) throw new Error(`Password string too short (min ${options.minPasswordlength} characters required)`);
		let { salt = "" } = options;
		if (!salt) {
			const { saltBits = 0 } = options;
			if (!saltBits) throw new Error("Missing salt and saltBits options");
			const randomSalt = randomBits(_crypto$1, saltBits);
			salt = [...new Uint8Array(randomSalt)].map((x) => x.toString(16).padStart(2, "0")).join("");
		}
		const derivedKey = await pbkdf2(_crypto$1, password, salt, options.iterations, algorithm.keyBits / 8, "SHA-1");
		result.key = await _crypto$1.subtle.importKey("raw", derivedKey, id, false, usage);
		result.salt = salt;
	} else {
		if (password.length < algorithm.keyBits / 8) throw new Error("Key buffer (password) too small");
		result.key = await _crypto$1.subtle.importKey("raw", password, id, false, usage);
		result.salt = "";
	}
	if (options.iv) result.iv = options.iv;
	else if ("ivBits" in algorithm) result.iv = randomBits(_crypto$1, algorithm.ivBits);
	return result;
};
var getEncryptParams = (algorithm, key, data) => {
	return [
		algorithm === "aes-128-ctr" ? {
			name: "AES-CTR",
			counter: key.iv,
			length: 128
		} : {
			name: "AES-CBC",
			iv: key.iv
		},
		key.key,
		typeof data === "string" ? stringToBuffer(data) : data
	];
};
var encrypt = async (_crypto$1, password, options, data) => {
	const key = await generateKey(_crypto$1, password, options);
	const encrypted = await _crypto$1.subtle.encrypt(...getEncryptParams(options.algorithm, key, data));
	return {
		encrypted: new Uint8Array(encrypted),
		key
	};
};
var decrypt = async (_crypto$1, password, options, data) => {
	const key = await generateKey(_crypto$1, password, options);
	const decrypted = await _crypto$1.subtle.decrypt(...getEncryptParams(options.algorithm, key, data));
	return bufferToString(new Uint8Array(decrypted));
};
var hmacWithPassword = async (_crypto$1, password, options, data) => {
	const key = await generateKey(_crypto$1, password, {
		...options,
		hmac: true
	});
	const textBuffer = stringToBuffer(data);
	const signed = await _crypto$1.subtle.sign({ name: "HMAC" }, key.key, textBuffer);
	return {
		digest: base64urlEncode(new Uint8Array(signed)),
		salt: key.salt
	};
};
var normalizePassword = (password) => {
	if (typeof password === "string" || password instanceof Uint8Array) return {
		encryption: password,
		integrity: password
	};
	if ("secret" in password) return {
		id: password.id,
		encryption: password.secret,
		integrity: password.secret
	};
	return {
		id: password.id,
		encryption: password.encryption,
		integrity: password.integrity
	};
};
var seal = async (_crypto$1, object, password, options) => {
	if (!password) throw new Error("Empty password");
	const opts = clone(options);
	const now = Date.now() + (opts.localtimeOffsetMsec || 0);
	const objectString = JSON.stringify(object);
	const { id = "", encryption, integrity } = normalizePassword(password);
	if (id && !/^\w+$/.test(id)) throw new Error("Invalid password id");
	const { encrypted, key } = await encrypt(_crypto$1, encryption, opts.encryption, objectString);
	const encryptedB64 = base64urlEncode(new Uint8Array(encrypted));
	const iv = base64urlEncode(key.iv);
	const expiration = opts.ttl ? now + opts.ttl : "";
	const macBaseString = `${macPrefix}*${id}*${key.salt}*${iv}*${encryptedB64}*${expiration}`;
	const mac = await hmacWithPassword(_crypto$1, integrity, opts.integrity, macBaseString);
	return `${macBaseString}*${mac.salt}*${mac.digest}`;
};
var fixedTimeComparison = (a, b) => {
	let mismatch = a.length === b.length ? 0 : 1;
	if (mismatch) b = a;
	for (let i = 0; i < a.length; i += 1) mismatch |= a.charCodeAt(i) ^ b.charCodeAt(i);
	return mismatch === 0;
};
var unseal = async (_crypto$1, sealed, password, options) => {
	if (!password) throw new Error("Empty password");
	const opts = clone(options);
	const now = Date.now() + (opts.localtimeOffsetMsec || 0);
	const parts = sealed.split("*");
	if (parts.length !== 8) throw new Error("Incorrect number of sealed components");
	const prefix = parts[0];
	let passwordId = parts[1];
	const encryptionSalt = parts[2];
	const encryptionIv = parts[3];
	const encryptedB64 = parts[4];
	const expiration = parts[5];
	const hmacSalt = parts[6];
	const hmac = parts[7];
	const macBaseString = `${prefix}*${passwordId}*${encryptionSalt}*${encryptionIv}*${encryptedB64}*${expiration}`;
	if (macPrefix !== prefix) throw new Error("Wrong mac prefix");
	if (expiration) {
		if (!/^\d+$/.test(expiration)) throw new Error("Invalid expiration");
		if (Number.parseInt(expiration, 10) <= now - opts.timestampSkewSec * 1e3) throw new Error("Expired seal");
	}
	let pass = "";
	passwordId = passwordId || "default";
	if (typeof password === "string" || password instanceof Uint8Array) pass = password;
	else if (passwordId in password) pass = password[passwordId];
	else throw new Error(`Cannot find password: ${passwordId}`);
	pass = normalizePassword(pass);
	const macOptions = opts.integrity;
	macOptions.salt = hmacSalt;
	if (!fixedTimeComparison((await hmacWithPassword(_crypto$1, pass.integrity, macOptions, macBaseString)).digest, hmac)) throw new Error("Bad hmac value");
	const encrypted = base64urlDecode(encryptedB64);
	const decryptOptions = opts.encryption;
	decryptOptions.salt = encryptionSalt;
	decryptOptions.iv = base64urlDecode(encryptionIv);
	const decrypted = await decrypt(_crypto$1, pass.encryption, decryptOptions, encrypted);
	if (decrypted) return JSON.parse(decrypted);
	return null;
};

//#endregion
//#region ../../node_modules/.pnpm/h3@1.13.0/node_modules/h3/dist/index.mjs
function hasProp(obj, prop) {
	try {
		return prop in obj;
	} catch {
		return false;
	}
}
var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {
	enumerable: true,
	configurable: true,
	writable: true,
	value
}) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
	__defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
	return value;
};
var H3Error = class extends Error {
	constructor(message, opts = {}) {
		super(message, opts);
		__publicField$2(this, "statusCode", 500);
		__publicField$2(this, "fatal", false);
		__publicField$2(this, "unhandled", false);
		__publicField$2(this, "statusMessage");
		__publicField$2(this, "data");
		__publicField$2(this, "cause");
		if (opts.cause && !this.cause) this.cause = opts.cause;
	}
	toJSON() {
		const obj = {
			message: this.message,
			statusCode: sanitizeStatusCode(this.statusCode, 500)
		};
		if (this.statusMessage) obj.statusMessage = sanitizeStatusMessage(this.statusMessage);
		if (this.data !== void 0) obj.data = this.data;
		return obj;
	}
};
__publicField$2(H3Error, "__h3_error__", true);
function createError(input) {
	if (typeof input === "string") return new H3Error(input);
	if (isError(input)) return input;
	const err = new H3Error(input.message ?? input.statusMessage ?? "", { cause: input.cause || input });
	if (hasProp(input, "stack")) try {
		Object.defineProperty(err, "stack", { get() {
			return input.stack;
		} });
	} catch {
		try {
			err.stack = input.stack;
		} catch {}
	}
	if (input.data) err.data = input.data;
	if (input.statusCode) err.statusCode = sanitizeStatusCode(input.statusCode, err.statusCode);
	else if (input.status) err.statusCode = sanitizeStatusCode(input.status, err.statusCode);
	if (input.statusMessage) err.statusMessage = input.statusMessage;
	else if (input.statusText) err.statusMessage = input.statusText;
	if (err.statusMessage) {
		const originalMessage = err.statusMessage;
		if (sanitizeStatusMessage(err.statusMessage) !== originalMessage) console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.");
	}
	if (input.fatal !== void 0) err.fatal = input.fatal;
	if (input.unhandled !== void 0) err.unhandled = input.unhandled;
	return err;
}
function sendError(event, error, debug) {
	if (event.handled) return;
	const h3Error = isError(error) ? error : createError(error);
	const responseBody = {
		statusCode: h3Error.statusCode,
		statusMessage: h3Error.statusMessage,
		stack: [],
		data: h3Error.data
	};
	if (debug) responseBody.stack = (h3Error.stack || "").split("\n").map((l) => l.trim());
	if (event.handled) return;
	setResponseStatus(event, Number.parseInt(h3Error.statusCode), h3Error.statusMessage);
	event.node.res.setHeader("content-type", MIMES.json);
	event.node.res.end(JSON.stringify(responseBody, void 0, 2));
}
function isError(input) {
	return input?.constructor?.__h3_error__ === true;
}
function parse$1(multipartBodyBuffer, boundary) {
	let lastline = "";
	let state = 0;
	let buffer = [];
	const allParts = [];
	let currentPartHeaders = [];
	for (let i = 0; i < multipartBodyBuffer.length; i++) {
		const prevByte = i > 0 ? multipartBodyBuffer[i - 1] : null;
		const currByte = multipartBodyBuffer[i];
		if (!(currByte === 10 || currByte === 13)) lastline += String.fromCodePoint(currByte);
		const newLineDetected = currByte === 10 && prevByte === 13;
		if (0 === state && newLineDetected) {
			if ("--" + boundary === lastline) state = 1;
			lastline = "";
		} else if (1 === state && newLineDetected) {
			if (lastline.length > 0) {
				const i2 = lastline.indexOf(":");
				if (i2 > 0) {
					const name = lastline.slice(0, i2).toLowerCase();
					const value = lastline.slice(i2 + 1).trim();
					currentPartHeaders.push([name, value]);
				}
			} else {
				state = 2;
				buffer = [];
			}
			lastline = "";
		} else if (2 === state) {
			if (lastline.length > boundary.length + 4) lastline = "";
			if ("--" + boundary === lastline) {
				const j = buffer.length - lastline.length;
				const part = buffer.slice(0, j - 1);
				allParts.push(process(part, currentPartHeaders));
				buffer = [];
				currentPartHeaders = [];
				lastline = "";
				state = 3;
			} else buffer.push(currByte);
			if (newLineDetected) lastline = "";
		} else if (3 === state && newLineDetected) state = 1;
	}
	return allParts;
}
function process(data, headers) {
	const dataObj = {};
	const contentDispositionHeader = headers.find((h) => h[0] === "content-disposition")?.[1] || "";
	for (const i of contentDispositionHeader.split(";")) {
		const s = i.split("=");
		if (s.length !== 2) continue;
		const key = (s[0] || "").trim();
		if (key === "name" || key === "filename") {
			const _value = (s[1] || "").trim().replace(/"/g, "");
			dataObj[key] = Buffer.from(_value, "latin1").toString("utf8");
		}
	}
	const contentType = headers.find((h) => h[0] === "content-type")?.[1] || "";
	if (contentType) dataObj.type = contentType;
	dataObj.data = Buffer.from(data);
	return dataObj;
}
async function validateData(data, fn) {
	try {
		const res = await fn(data);
		if (res === false) throw createValidationError();
		if (res === true) return data;
		return res ?? data;
	} catch (error) {
		throw createValidationError(error);
	}
}
function createValidationError(validateError) {
	throw createError({
		status: 400,
		statusMessage: "Validation Error",
		message: validateError?.message || "Validation Error",
		data: validateError
	});
}
function getQuery(event) {
	return getQuery$2(event.path || "");
}
function getValidatedQuery(event, validate) {
	return validateData(getQuery(event), validate);
}
function getRouterParams(event, opts = {}) {
	let params = event.context.params || {};
	if (opts.decode) {
		params = { ...params };
		for (const key in params) params[key] = decode(params[key]);
	}
	return params;
}
function getValidatedRouterParams(event, validate, opts = {}) {
	return validateData(getRouterParams(event, opts), validate);
}
function getRouterParam(event, name, opts = {}) {
	return getRouterParams(event, opts)[name];
}
function isMethod(event, expected, allowHead) {
	if (allowHead && event.method === "HEAD") return true;
	if (typeof expected === "string") {
		if (event.method === expected) return true;
	} else if (expected.includes(event.method)) return true;
	return false;
}
function assertMethod(event, expected, allowHead) {
	if (!isMethod(event, expected, allowHead)) throw createError({
		statusCode: 405,
		statusMessage: "HTTP method is not allowed."
	});
}
function getRequestHeaders(event) {
	const _headers = {};
	for (const key in event.node.req.headers) {
		const val = event.node.req.headers[key];
		_headers[key] = Array.isArray(val) ? val.filter(Boolean).join(", ") : val;
	}
	return _headers;
}
const getHeaders = getRequestHeaders;
function getRequestHeader(event, name) {
	return getRequestHeaders(event)[name.toLowerCase()];
}
const getHeader = getRequestHeader;
function getRequestHost(event, opts = {}) {
	if (opts.xForwardedHost) {
		const xForwardedHost = event.node.req.headers["x-forwarded-host"];
		if (xForwardedHost) return xForwardedHost;
	}
	return event.node.req.headers.host || "localhost";
}
function getRequestProtocol(event, opts = {}) {
	if (opts.xForwardedProto !== false && event.node.req.headers["x-forwarded-proto"] === "https") return "https";
	return event.node.req.connection?.encrypted ? "https" : "http";
}
function getRequestURL(event, opts = {}) {
	const host = getRequestHost(event, opts);
	const protocol = getRequestProtocol(event, opts);
	const path = (event.node.req.originalUrl || event.path).replace(/^[/\\]+/g, "/");
	return new URL(path, `${protocol}://${host}`);
}
function toWebRequest(event) {
	return event.web?.request || new Request(getRequestURL(event), {
		duplex: "half",
		method: event.method,
		headers: event.headers,
		body: getRequestWebStream(event)
	});
}
function getRequestIP(event, opts = {}) {
	if (event.context.clientAddress) return event.context.clientAddress;
	if (opts.xForwardedFor) {
		const xForwardedFor = getRequestHeader(event, "x-forwarded-for")?.split(",").shift()?.trim();
		if (xForwardedFor) return xForwardedFor;
	}
	if (event.node.req.socket.remoteAddress) return event.node.req.socket.remoteAddress;
}
const RawBodySymbol = Symbol.for("h3RawBody");
const ParsedBodySymbol = Symbol.for("h3ParsedBody");
const PayloadMethods$1 = [
	"PATCH",
	"POST",
	"PUT",
	"DELETE"
];
function readRawBody(event, encoding = "utf8") {
	assertMethod(event, PayloadMethods$1);
	const _rawBody = event._requestBody || event.web?.request?.body || event.node.req[RawBodySymbol] || event.node.req.rawBody || event.node.req.body;
	if (_rawBody) {
		const promise2 = Promise.resolve(_rawBody).then((_resolved) => {
			if (Buffer.isBuffer(_resolved)) return _resolved;
			if (typeof _resolved.pipeTo === "function") return new Promise((resolve, reject) => {
				const chunks = [];
				_resolved.pipeTo(new WritableStream({
					write(chunk) {
						chunks.push(chunk);
					},
					close() {
						resolve(Buffer.concat(chunks));
					},
					abort(reason) {
						reject(reason);
					}
				})).catch(reject);
			});
			else if (typeof _resolved.pipe === "function") return new Promise((resolve, reject) => {
				const chunks = [];
				_resolved.on("data", (chunk) => {
					chunks.push(chunk);
				}).on("end", () => {
					resolve(Buffer.concat(chunks));
				}).on("error", reject);
			});
			if (_resolved.constructor === Object) return Buffer.from(JSON.stringify(_resolved));
			if (_resolved instanceof URLSearchParams) return Buffer.from(_resolved.toString());
			return Buffer.from(_resolved);
		});
		return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;
	}
	if (!Number.parseInt(event.node.req.headers["content-length"] || "") && !String(event.node.req.headers["transfer-encoding"] ?? "").split(",").map((e) => e.trim()).filter(Boolean).includes("chunked")) return Promise.resolve(void 0);
	const promise = event.node.req[RawBodySymbol] = new Promise((resolve, reject) => {
		const bodyData = [];
		event.node.req.on("error", (err) => {
			reject(err);
		}).on("data", (chunk) => {
			bodyData.push(chunk);
		}).on("end", () => {
			resolve(Buffer.concat(bodyData));
		});
	});
	return encoding ? promise.then((buff) => buff.toString(encoding)) : promise;
}
async function readBody(event, options = {}) {
	const request = event.node.req;
	if (hasProp(request, ParsedBodySymbol)) return request[ParsedBodySymbol];
	const contentType = request.headers["content-type"] || "";
	const body = await readRawBody(event);
	let parsed;
	if (contentType === "application/json") parsed = _parseJSON(body, options.strict ?? true);
	else if (contentType.startsWith("application/x-www-form-urlencoded")) parsed = _parseURLEncodedBody(body);
	else if (contentType.startsWith("text/")) parsed = body;
	else parsed = _parseJSON(body, options.strict ?? false);
	request[ParsedBodySymbol] = parsed;
	return parsed;
}
async function readValidatedBody(event, validate) {
	return validateData(await readBody(event, { strict: true }), validate);
}
async function readMultipartFormData(event) {
	const contentType = getRequestHeader(event, "content-type");
	if (!contentType || !contentType.startsWith("multipart/form-data")) return;
	const boundary = contentType.match(/boundary=([^;]*)(;|$)/i)?.[1];
	if (!boundary) return;
	const body = await readRawBody(event, false);
	if (!body) return;
	return parse$1(body, boundary);
}
async function readFormData(event) {
	return await toWebRequest(event).formData();
}
function getRequestWebStream(event) {
	if (!PayloadMethods$1.includes(event.method)) return;
	const bodyStream = event.web?.request?.body || event._requestBody;
	if (bodyStream) return bodyStream;
	if (RawBodySymbol in event.node.req || "rawBody" in event.node.req || "body" in event.node.req || "__unenv__" in event.node.req) return new ReadableStream({ async start(controller) {
		const _rawBody = await readRawBody(event, false);
		if (_rawBody) controller.enqueue(_rawBody);
		controller.close();
	} });
	return new ReadableStream({ start: (controller) => {
		event.node.req.on("data", (chunk) => {
			controller.enqueue(chunk);
		});
		event.node.req.on("end", () => {
			controller.close();
		});
		event.node.req.on("error", (err) => {
			controller.error(err);
		});
	} });
}
function _parseJSON(body = "", strict) {
	if (!body) return;
	try {
		return destr(body, { strict });
	} catch {
		throw createError({
			statusCode: 400,
			statusMessage: "Bad Request",
			message: "Invalid JSON body"
		});
	}
}
function _parseURLEncodedBody(body) {
	const form = new URLSearchParams(body);
	const parsedForm = /* @__PURE__ */ Object.create(null);
	for (const [key, value] of form.entries()) if (hasProp(parsedForm, key)) {
		if (!Array.isArray(parsedForm[key])) parsedForm[key] = [parsedForm[key]];
		parsedForm[key].push(value);
	} else parsedForm[key] = value;
	return parsedForm;
}
function handleCacheHeaders(event, opts) {
	const cacheControls = ["public", ...opts.cacheControls || []];
	let cacheMatched = false;
	if (opts.maxAge !== void 0) cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);
	if (opts.modifiedTime) {
		const modifiedTime = new Date(opts.modifiedTime);
		const ifModifiedSince = event.node.req.headers["if-modified-since"];
		event.node.res.setHeader("last-modified", modifiedTime.toUTCString());
		if (ifModifiedSince && new Date(ifModifiedSince) >= opts.modifiedTime) cacheMatched = true;
	}
	if (opts.etag) {
		event.node.res.setHeader("etag", opts.etag);
		if (event.node.req.headers["if-none-match"] === opts.etag) cacheMatched = true;
	}
	event.node.res.setHeader("cache-control", cacheControls.join(", "));
	if (cacheMatched) {
		event.node.res.statusCode = 304;
		if (!event.handled) event.node.res.end();
		return true;
	}
	return false;
}
const MIMES = {
	html: "text/html",
	json: "application/json"
};
const DISALLOWED_STATUS_CHARS = /[^\u0009\u0020-\u007E]/g;
function sanitizeStatusMessage(statusMessage = "") {
	return statusMessage.replace(DISALLOWED_STATUS_CHARS, "");
}
function sanitizeStatusCode(statusCode, defaultStatusCode = 200) {
	if (!statusCode) return defaultStatusCode;
	if (typeof statusCode === "string") statusCode = Number.parseInt(statusCode, 10);
	if (statusCode < 100 || statusCode > 999) return defaultStatusCode;
	return statusCode;
}
function parseCookies(event) {
	return parse(event.node.req.headers.cookie || "");
}
function getCookie(event, name) {
	return parseCookies(event)[name];
}
function setCookie$1(event, name, value, serializeOptions) {
	serializeOptions = {
		path: "/",
		...serializeOptions
	};
	const cookieStr = serialize(name, value, serializeOptions);
	let setCookies = event.node.res.getHeader("set-cookie");
	if (!Array.isArray(setCookies)) setCookies = [setCookies];
	const _optionsHash = objectHash(serializeOptions);
	setCookies = setCookies.filter((cookieValue) => {
		return cookieValue && _optionsHash !== objectHash(parse(cookieValue));
	});
	event.node.res.setHeader("set-cookie", [...setCookies, cookieStr]);
}
function deleteCookie(event, name, serializeOptions) {
	setCookie$1(event, name, "", {
		...serializeOptions,
		maxAge: 0
	});
}
function splitCookiesString(cookiesString) {
	if (Array.isArray(cookiesString)) return cookiesString.flatMap((c) => splitCookiesString(c));
	if (typeof cookiesString !== "string") return [];
	const cookiesStrings = [];
	let pos = 0;
	let start;
	let ch;
	let lastComma;
	let nextStart;
	let cookiesSeparatorFound;
	const skipWhitespace = () => {
		while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) pos += 1;
		return pos < cookiesString.length;
	};
	const notSpecialChar = () => {
		ch = cookiesString.charAt(pos);
		return ch !== "=" && ch !== ";" && ch !== ",";
	};
	while (pos < cookiesString.length) {
		start = pos;
		cookiesSeparatorFound = false;
		while (skipWhitespace()) {
			ch = cookiesString.charAt(pos);
			if (ch === ",") {
				lastComma = pos;
				pos += 1;
				skipWhitespace();
				nextStart = pos;
				while (pos < cookiesString.length && notSpecialChar()) pos += 1;
				if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
					cookiesSeparatorFound = true;
					pos = nextStart;
					cookiesStrings.push(cookiesString.slice(start, lastComma));
					start = pos;
				} else pos = lastComma + 1;
			} else pos += 1;
		}
		if (!cookiesSeparatorFound || pos >= cookiesString.length) cookiesStrings.push(cookiesString.slice(start));
	}
	return cookiesStrings;
}
const defer = typeof setImmediate === "undefined" ? (fn) => fn() : setImmediate;
function send(event, data, type) {
	if (type) defaultContentType(event, type);
	return new Promise((resolve) => {
		defer(() => {
			if (!event.handled) event.node.res.end(data);
			resolve();
		});
	});
}
function sendNoContent(event, code) {
	if (event.handled) return;
	if (!code && event.node.res.statusCode !== 200) code = event.node.res.statusCode;
	const _code = sanitizeStatusCode(code, 204);
	if (_code === 204) event.node.res.removeHeader("content-length");
	event.node.res.writeHead(_code);
	event.node.res.end();
}
function setResponseStatus(event, code, text) {
	if (code) event.node.res.statusCode = sanitizeStatusCode(code, event.node.res.statusCode);
	if (text) event.node.res.statusMessage = sanitizeStatusMessage(text);
}
function getResponseStatus(event) {
	return event.node.res.statusCode;
}
function getResponseStatusText(event) {
	return event.node.res.statusMessage;
}
function defaultContentType(event, type) {
	if (type && event.node.res.statusCode !== 304 && !event.node.res.getHeader("content-type")) event.node.res.setHeader("content-type", type);
}
function sendRedirect(event, location, code = 302) {
	event.node.res.statusCode = sanitizeStatusCode(code, event.node.res.statusCode);
	event.node.res.setHeader("location", location);
	return send(event, `<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=${location.replace(/"/g, "%22")}"></head></html>`, MIMES.html);
}
function getResponseHeaders(event) {
	return event.node.res.getHeaders();
}
function getResponseHeader(event, name) {
	return event.node.res.getHeader(name);
}
function setResponseHeaders(event, headers) {
	for (const [name, value] of Object.entries(headers)) event.node.res.setHeader(name, value);
}
const setHeaders = setResponseHeaders;
function setResponseHeader(event, name, value) {
	event.node.res.setHeader(name, value);
}
const setHeader = setResponseHeader;
function appendResponseHeaders(event, headers) {
	for (const [name, value] of Object.entries(headers)) appendResponseHeader(event, name, value);
}
const appendHeaders = appendResponseHeaders;
function appendResponseHeader(event, name, value) {
	let current = event.node.res.getHeader(name);
	if (!current) {
		event.node.res.setHeader(name, value);
		return;
	}
	if (!Array.isArray(current)) current = [current.toString()];
	event.node.res.setHeader(name, [...current, value]);
}
const appendHeader = appendResponseHeader;
function clearResponseHeaders(event, headerNames) {
	if (headerNames && headerNames.length > 0) for (const name of headerNames) removeResponseHeader(event, name);
	else for (const [name] of Object.entries(getResponseHeaders(event))) removeResponseHeader(event, name);
}
function removeResponseHeader(event, name) {
	return event.node.res.removeHeader(name);
}
function sendStream(event, stream) {
	if (!stream || typeof stream !== "object") throw new Error("[h3] Invalid stream provided.");
	event.node.res._data = stream;
	if (!event.node.res.socket) {
		event._handled = true;
		return Promise.resolve();
	}
	if (hasProp(stream, "pipeTo") && typeof stream.pipeTo === "function") return stream.pipeTo(new WritableStream({ write(chunk) {
		event.node.res.write(chunk);
	} })).then(() => {
		event.node.res.end();
	});
	if (hasProp(stream, "pipe") && typeof stream.pipe === "function") return new Promise((resolve, reject) => {
		stream.pipe(event.node.res);
		if (stream.on) {
			stream.on("end", () => {
				event.node.res.end();
				resolve();
			});
			stream.on("error", (error) => {
				reject(error);
			});
		}
		event.node.res.on("close", () => {
			if (stream.abort) stream.abort();
		});
	});
	throw new Error("[h3] Invalid or incompatible stream provided.");
}
const noop = () => {};
function writeEarlyHints(event, hints, cb = noop) {
	if (!event.node.res.socket) {
		cb();
		return;
	}
	if (typeof hints === "string" || Array.isArray(hints)) hints = { link: hints };
	if (hints.link) hints.link = Array.isArray(hints.link) ? hints.link : hints.link.split(",");
	const headers = Object.entries(hints).map((e) => [e[0].toLowerCase(), e[1]]);
	if (headers.length === 0) {
		cb();
		return;
	}
	let hint = "HTTP/1.1 103 Early Hints";
	if (hints.link) hint += `\r
Link: ${hints.link.join(", ")}`;
	for (const [header, value] of headers) {
		if (header === "link") continue;
		hint += `\r
${header}: ${value}`;
	}
	if (event.node.res.socket) event.node.res.socket.write(`${hint}\r
\r
`, "utf8", cb);
	else cb();
}
function sendWebResponse(event, response) {
	for (const [key, value] of response.headers) if (key === "set-cookie") event.node.res.appendHeader(key, splitCookiesString(value));
	else event.node.res.setHeader(key, value);
	if (response.status) event.node.res.statusCode = sanitizeStatusCode(response.status, event.node.res.statusCode);
	if (response.statusText) event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);
	if (response.redirected) event.node.res.setHeader("location", response.url);
	if (!response.body) {
		event.node.res.end();
		return;
	}
	return sendStream(event, response.body);
}
function resolveCorsOptions(options = {}) {
	return defu(options, {
		origin: "*",
		methods: "*",
		allowHeaders: "*",
		exposeHeaders: "*",
		credentials: false,
		maxAge: false,
		preflight: { statusCode: 204 }
	});
}
function isPreflightRequest(event) {
	const origin = getRequestHeader(event, "origin");
	const accessControlRequestMethod = getRequestHeader(event, "access-control-request-method");
	return event.method === "OPTIONS" && !!origin && !!accessControlRequestMethod;
}
function isCorsOriginAllowed(origin, options) {
	const { origin: originOption } = options;
	if (!origin || !originOption || originOption === "*" || originOption === "null") return true;
	if (Array.isArray(originOption)) return originOption.some((_origin) => {
		if (_origin instanceof RegExp) return _origin.test(origin);
		return origin === _origin;
	});
	return originOption(origin);
}
function createOriginHeaders(event, options) {
	const { origin: originOption } = options;
	const origin = getRequestHeader(event, "origin");
	if (!origin || !originOption || originOption === "*") return { "access-control-allow-origin": "*" };
	if (typeof originOption === "string") return {
		"access-control-allow-origin": originOption,
		vary: "origin"
	};
	return isCorsOriginAllowed(origin, options) ? {
		"access-control-allow-origin": origin,
		vary: "origin"
	} : {};
}
function createMethodsHeaders(options) {
	const { methods } = options;
	if (!methods) return {};
	if (methods === "*") return { "access-control-allow-methods": "*" };
	return methods.length > 0 ? { "access-control-allow-methods": methods.join(",") } : {};
}
function createCredentialsHeaders(options) {
	const { credentials } = options;
	if (credentials) return { "access-control-allow-credentials": "true" };
	return {};
}
function createAllowHeaderHeaders(event, options) {
	const { allowHeaders } = options;
	if (!allowHeaders || allowHeaders === "*" || allowHeaders.length === 0) {
		const header = getRequestHeader(event, "access-control-request-headers");
		return header ? {
			"access-control-allow-headers": header,
			vary: "access-control-request-headers"
		} : {};
	}
	return {
		"access-control-allow-headers": allowHeaders.join(","),
		vary: "access-control-request-headers"
	};
}
function createExposeHeaders(options) {
	const { exposeHeaders } = options;
	if (!exposeHeaders) return {};
	if (exposeHeaders === "*") return { "access-control-expose-headers": exposeHeaders };
	return { "access-control-expose-headers": exposeHeaders.join(",") };
}
function appendCorsPreflightHeaders(event, options) {
	appendHeaders(event, createOriginHeaders(event, options));
	appendHeaders(event, createCredentialsHeaders(options));
	appendHeaders(event, createExposeHeaders(options));
	appendHeaders(event, createMethodsHeaders(options));
	appendHeaders(event, createAllowHeaderHeaders(event, options));
}
function appendCorsHeaders(event, options) {
	appendHeaders(event, createOriginHeaders(event, options));
	appendHeaders(event, createCredentialsHeaders(options));
	appendHeaders(event, createExposeHeaders(options));
}
function handleCors(event, options) {
	const _options = resolveCorsOptions(options);
	if (isPreflightRequest(event)) {
		appendCorsPreflightHeaders(event, options);
		sendNoContent(event, _options.preflight.statusCode);
		return true;
	}
	appendCorsHeaders(event, options);
	return false;
}
async function getRequestFingerprint(event, opts = {}) {
	const fingerprint = [];
	if (opts.ip !== false) fingerprint.push(getRequestIP(event, { xForwardedFor: opts.xForwardedFor }));
	if (opts.method === true) fingerprint.push(event.method);
	if (opts.path === true) fingerprint.push(event.path);
	if (opts.userAgent === true) fingerprint.push(getRequestHeader(event, "user-agent"));
	const fingerprintString = fingerprint.filter(Boolean).join("|");
	if (!fingerprintString) return null;
	if (opts.hash === false) return fingerprintString;
	const buffer = await _crypto.subtle.digest(opts.hash || "SHA-1", new TextEncoder().encode(fingerprintString));
	return [...new Uint8Array(buffer)].map((b) => b.toString(16).padStart(2, "0")).join("");
}
const PayloadMethods = /* @__PURE__ */ new Set([
	"PATCH",
	"POST",
	"PUT",
	"DELETE"
]);
const ignoredHeaders = /* @__PURE__ */ new Set([
	"transfer-encoding",
	"connection",
	"keep-alive",
	"upgrade",
	"expect",
	"host",
	"accept"
]);
async function proxyRequest(event, target, opts = {}) {
	let body;
	let duplex;
	if (PayloadMethods.has(event.method)) if (opts.streamRequest) {
		body = getRequestWebStream(event);
		duplex = "half";
	} else body = await readRawBody(event, false).catch(() => void 0);
	const method = opts.fetchOptions?.method || event.method;
	const fetchHeaders = mergeHeaders(getProxyRequestHeaders(event), opts.fetchOptions?.headers, opts.headers);
	return sendProxy(event, target, {
		...opts,
		fetchOptions: {
			method,
			body,
			duplex,
			...opts.fetchOptions,
			headers: fetchHeaders
		}
	});
}
async function sendProxy(event, target, opts = {}) {
	let response;
	try {
		response = await _getFetch(opts.fetch)(target, {
			headers: opts.headers,
			ignoreResponseError: true,
			...opts.fetchOptions
		});
	} catch (error) {
		throw createError({
			status: 502,
			statusMessage: "Bad Gateway",
			cause: error
		});
	}
	event.node.res.statusCode = sanitizeStatusCode(response.status, event.node.res.statusCode);
	event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);
	const cookies = [];
	for (const [key, value] of response.headers.entries()) {
		if (key === "content-encoding") continue;
		if (key === "content-length") continue;
		if (key === "set-cookie") {
			cookies.push(...splitCookiesString(value));
			continue;
		}
		event.node.res.setHeader(key, value);
	}
	if (cookies.length > 0) event.node.res.setHeader("set-cookie", cookies.map((cookie) => {
		if (opts.cookieDomainRewrite) cookie = rewriteCookieProperty(cookie, opts.cookieDomainRewrite, "domain");
		if (opts.cookiePathRewrite) cookie = rewriteCookieProperty(cookie, opts.cookiePathRewrite, "path");
		return cookie;
	}));
	if (opts.onResponse) await opts.onResponse(event, response);
	if (response._data !== void 0) return response._data;
	if (event.handled) return;
	if (opts.sendStream === false) {
		const data = new Uint8Array(await response.arrayBuffer());
		return event.node.res.end(data);
	}
	if (response.body) for await (const chunk of response.body) event.node.res.write(chunk);
	return event.node.res.end();
}
function getProxyRequestHeaders(event) {
	const headers = /* @__PURE__ */ Object.create(null);
	const reqHeaders = getRequestHeaders(event);
	for (const name in reqHeaders) if (!ignoredHeaders.has(name)) headers[name] = reqHeaders[name];
	return headers;
}
function fetchWithEvent(event, req, init, options) {
	return _getFetch(options?.fetch)(req, {
		...init,
		context: init?.context || event.context,
		headers: {
			...getProxyRequestHeaders(event),
			...init?.headers
		}
	});
}
function _getFetch(_fetch) {
	if (_fetch) return _fetch;
	if (globalThis.fetch) return globalThis.fetch;
	throw new Error("fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js.");
}
function rewriteCookieProperty(header, map, property) {
	const _map = typeof map === "string" ? { "*": map } : map;
	return header.replace(new RegExp(`(;\\s*${property}=)([^;]+)`, "gi"), (match, prefix, previousValue) => {
		let newValue;
		if (previousValue in _map) newValue = _map[previousValue];
		else if ("*" in _map) newValue = _map["*"];
		else return match;
		return newValue ? prefix + newValue : "";
	});
}
function mergeHeaders(defaults$2, ...inputs) {
	const _inputs = inputs.filter(Boolean);
	if (_inputs.length === 0) return defaults$2;
	const merged = new Headers(defaults$2);
	for (const input of _inputs) for (const [key, value] of Object.entries(input)) if (value !== void 0) merged.set(key, value);
	return merged;
}
const getSessionPromise = Symbol("getSession");
const DEFAULT_NAME = "h3";
const DEFAULT_COOKIE = {
	path: "/",
	secure: true,
	httpOnly: true
};
async function useSession(event, config) {
	const sessionName = config.name || DEFAULT_NAME;
	await getSession(event, config);
	const sessionManager = {
		get id() {
			return event.context.sessions?.[sessionName]?.id;
		},
		get data() {
			return event.context.sessions?.[sessionName]?.data || {};
		},
		update: async (update) => {
			await updateSession(event, config, update);
			return sessionManager;
		},
		clear: () => {
			clearSession(event, config);
			return Promise.resolve(sessionManager);
		}
	};
	return sessionManager;
}
async function getSession(event, config) {
	const sessionName = config.name || DEFAULT_NAME;
	if (!event.context.sessions) event.context.sessions = /* @__PURE__ */ Object.create(null);
	const existingSession = event.context.sessions[sessionName];
	if (existingSession) return existingSession[getSessionPromise] || existingSession;
	const session = {
		id: "",
		createdAt: 0,
		data: /* @__PURE__ */ Object.create(null)
	};
	event.context.sessions[sessionName] = session;
	let sealedSession;
	if (config.sessionHeader !== false) {
		const headerName = typeof config.sessionHeader === "string" ? config.sessionHeader.toLowerCase() : `x-${sessionName.toLowerCase()}-session`;
		const headerValue = event.node.req.headers[headerName];
		if (typeof headerValue === "string") sealedSession = headerValue;
	}
	if (!sealedSession) sealedSession = getCookie(event, sessionName);
	if (sealedSession) {
		const promise = unsealSession(event, config, sealedSession).catch(() => {}).then((unsealed) => {
			Object.assign(session, unsealed);
			delete event.context.sessions[sessionName][getSessionPromise];
			return session;
		});
		event.context.sessions[sessionName][getSessionPromise] = promise;
		await promise;
	}
	if (!session.id) {
		session.id = config.generateId?.() ?? (config.crypto || _crypto).randomUUID();
		session.createdAt = Date.now();
		await updateSession(event, config);
	}
	return session;
}
async function updateSession(event, config, update) {
	const sessionName = config.name || DEFAULT_NAME;
	const session = event.context.sessions?.[sessionName] || await getSession(event, config);
	if (typeof update === "function") update = update(session.data);
	if (update) Object.assign(session.data, update);
	if (config.cookie !== false) setCookie$1(event, sessionName, await sealSession(event, config), {
		...DEFAULT_COOKIE,
		expires: config.maxAge ? new Date(session.createdAt + config.maxAge * 1e3) : void 0,
		...config.cookie
	});
	return session;
}
async function sealSession(event, config) {
	const sessionName = config.name || DEFAULT_NAME;
	const session = event.context.sessions?.[sessionName] || await getSession(event, config);
	return await seal(config.crypto || _crypto, session, config.password, {
		...defaults,
		ttl: config.maxAge ? config.maxAge * 1e3 : 0,
		...config.seal
	});
}
async function unsealSession(_event, config, sealed) {
	const unsealed = await unseal(config.crypto || _crypto, sealed, config.password, {
		...defaults,
		ttl: config.maxAge ? config.maxAge * 1e3 : 0,
		...config.seal
	});
	if (config.maxAge) {
		if (Date.now() - (unsealed.createdAt || Number.NEGATIVE_INFINITY) > config.maxAge * 1e3) throw new Error("Session expired!");
	}
	return unsealed;
}
function clearSession(event, config) {
	const sessionName = config.name || DEFAULT_NAME;
	if (event.context.sessions?.[sessionName]) delete event.context.sessions[sessionName];
	setCookie$1(event, sessionName, "", {
		...DEFAULT_COOKIE,
		...config.cookie
	});
	return Promise.resolve();
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
	enumerable: true,
	configurable: true,
	writable: true,
	value
}) : obj[key] = value;
var __publicField = (obj, key, value) => {
	__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
	return value;
};
var H3Event = class {
	constructor(req, res) {
		__publicField(this, "__is_event__", true);
		__publicField(this, "node");
		__publicField(this, "web");
		__publicField(this, "context", {});
		__publicField(this, "_method");
		__publicField(this, "_path");
		__publicField(this, "_headers");
		__publicField(this, "_requestBody");
		__publicField(this, "_handled", false);
		__publicField(this, "_onBeforeResponseCalled");
		__publicField(this, "_onAfterResponseCalled");
		this.node = {
			req,
			res
		};
	}
	get method() {
		if (!this._method) this._method = (this.node.req.method || "GET").toUpperCase();
		return this._method;
	}
	get path() {
		return this._path || this.node.req.url || "/";
	}
	get headers() {
		if (!this._headers) this._headers = _normalizeNodeHeaders(this.node.req.headers);
		return this._headers;
	}
	get handled() {
		return this._handled || this.node.res.writableEnded || this.node.res.headersSent;
	}
	respondWith(response) {
		return Promise.resolve(response).then((_response) => sendWebResponse(this, _response));
	}
	toString() {
		return `[${this.method}] ${this.path}`;
	}
	toJSON() {
		return this.toString();
	}
	/** @deprecated Please use `event.node.req` instead. */
	get req() {
		return this.node.req;
	}
	/** @deprecated Please use `event.node.res` instead. */
	get res() {
		return this.node.res;
	}
};
function _normalizeNodeHeaders(nodeHeaders) {
	const headers = new Headers();
	for (const [name, value] of Object.entries(nodeHeaders)) if (Array.isArray(value)) for (const item of value) headers.append(name, item);
	else if (value) headers.set(name, value);
	return headers;
}
const H3Headers = globalThis.Headers;
const H3Response = globalThis.Response;

//#endregion
//#region ../../node_modules/.pnpm/@tanstack+start-server-core@1.131.27/node_modules/@tanstack/start-server-core/dist/esm/h3.js
const eventStorage = new AsyncLocalStorage();
function _setContext(event, key, value) {
	event.context[key] = value;
}
function _getContext(event, key) {
	return event.context[key];
}
function getEvent() {
	const event = eventStorage.getStore();
	if (!event) throw new Error(`No HTTPEvent found in AsyncLocalStorage. Make sure you are using the function within the server runtime.`);
	return event;
}
const HTTPEventSymbol = Symbol("$HTTPEvent");
function isEvent(obj) {
	return typeof obj === "object" && (obj instanceof H3Event || (obj == null ? void 0 : obj[HTTPEventSymbol]) instanceof H3Event || (obj == null ? void 0 : obj.__is_event__) === true);
}
function createWrapperFunction(h3Function) {
	return function(...args) {
		const event = args[0];
		if (!isEvent(event)) args.unshift(getEvent());
		else args[0] = event instanceof H3Event || event.__is_event__ ? event : event[HTTPEventSymbol];
		return h3Function(...args);
	};
}
const readRawBody$1 = createWrapperFunction(readRawBody);
const readBody$1 = createWrapperFunction(readBody);
const getQuery$1 = createWrapperFunction(getQuery);
const isMethod$1 = createWrapperFunction(isMethod);
const isPreflightRequest$1 = createWrapperFunction(isPreflightRequest);
const getValidatedQuery$1 = createWrapperFunction(getValidatedQuery);
const getRouterParams$1 = createWrapperFunction(getRouterParams);
const getRouterParam$1 = createWrapperFunction(getRouterParam);
const getValidatedRouterParams$1 = createWrapperFunction(getValidatedRouterParams);
const assertMethod$1 = createWrapperFunction(assertMethod);
const getRequestHeaders$1 = createWrapperFunction(getRequestHeaders);
const getRequestHeader$1 = createWrapperFunction(getRequestHeader);
const getRequestURL$1 = createWrapperFunction(getRequestURL);
const getRequestHost$1 = createWrapperFunction(getRequestHost);
const getRequestProtocol$1 = createWrapperFunction(getRequestProtocol);
const getRequestIP$1 = createWrapperFunction(getRequestIP);
const send$1 = createWrapperFunction(send);
const sendNoContent$1 = createWrapperFunction(sendNoContent);
const setResponseStatus$1 = createWrapperFunction(setResponseStatus);
const getResponseStatus$1 = createWrapperFunction(getResponseStatus);
const getResponseStatusText$1 = createWrapperFunction(getResponseStatusText);
const getResponseHeaders$1 = createWrapperFunction(getResponseHeaders);
const getResponseHeader$1 = createWrapperFunction(getResponseHeader);
const setResponseHeaders$1 = createWrapperFunction(setResponseHeaders);
const setResponseHeader$1 = createWrapperFunction(setResponseHeader);
const appendResponseHeaders$1 = createWrapperFunction(appendResponseHeaders);
const appendResponseHeader$1 = createWrapperFunction(appendResponseHeader);
const defaultContentType$1 = createWrapperFunction(defaultContentType);
const sendRedirect$1 = createWrapperFunction(sendRedirect);
const sendStream$1 = createWrapperFunction(sendStream);
const writeEarlyHints$1 = createWrapperFunction(writeEarlyHints);
const sendError$1 = createWrapperFunction(sendError);
const sendProxy$1 = createWrapperFunction(sendProxy);
const proxyRequest$1 = createWrapperFunction(proxyRequest);
const fetchWithEvent$1 = createWrapperFunction(fetchWithEvent);
const getProxyRequestHeaders$1 = createWrapperFunction(getProxyRequestHeaders);
const parseCookies$1 = createWrapperFunction(parseCookies);
const getCookie$1 = createWrapperFunction(getCookie);
const setCookie = createWrapperFunction(setCookie$1);
const deleteCookie$1 = createWrapperFunction(deleteCookie);
const useSession$1 = createWrapperFunction(useSession);
const getSession$1 = createWrapperFunction(getSession);
const updateSession$1 = createWrapperFunction(updateSession);
const sealSession$1 = createWrapperFunction(sealSession);
const unsealSession$1 = createWrapperFunction(unsealSession);
const clearSession$1 = createWrapperFunction(clearSession);
const handleCacheHeaders$1 = createWrapperFunction(handleCacheHeaders);
const handleCors$1 = createWrapperFunction(handleCors);
const appendCorsHeaders$1 = createWrapperFunction(appendCorsHeaders);
const appendCorsPreflightHeaders$1 = createWrapperFunction(appendCorsPreflightHeaders);
const sendWebResponse$1 = createWrapperFunction(sendWebResponse);
const appendHeader$1 = createWrapperFunction(appendHeader);
const appendHeaders$1 = createWrapperFunction(appendHeaders);
const setHeader$1 = createWrapperFunction(setHeader);
const setHeaders$1 = createWrapperFunction(setHeaders);
const getHeader$1 = createWrapperFunction(getHeader);
const getHeaders$1 = createWrapperFunction(getHeaders);
const getRequestFingerprint$1 = createWrapperFunction(getRequestFingerprint);
const getRequestWebStream$1 = createWrapperFunction(getRequestWebStream);
const readFormData$1 = createWrapperFunction(readFormData);
const readMultipartFormData$1 = createWrapperFunction(readMultipartFormData);
const readValidatedBody$1 = createWrapperFunction(readValidatedBody);
const removeResponseHeader$1 = createWrapperFunction(removeResponseHeader);
const getContext = createWrapperFunction(_getContext);
const setContext = createWrapperFunction(_setContext);
const clearResponseHeaders$1 = createWrapperFunction(clearResponseHeaders);
const getWebRequest = createWrapperFunction(toWebRequest);

//#endregion
export { setCookie };